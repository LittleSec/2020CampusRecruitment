1. 构造函数从最初试的基类开始构造，**各个类中的同名变量没有形成覆盖**，都是单独的变量。
2. 就近调用原则：子类没有覆盖(即重写)父类的接口，则通过子类调用时，会调用最近的、有这个接口的祖先接口
3. 含有虚函数的类的对象中有一个虚表指针，指向虚表，虚表里存放了虚函数的地址
4. 虚函数继承和虚继承是两个完全不同的概念。虚继承是在继承时显式声明`virtual`, 如`class B : public virtual A`
    + 虚继承是多重继承中特有的概念，虚拟基类是为了解决多重继承而出现的
5. 虚继承类的大小(`sizeof`)问题: 如上例所示，B类里含有一个虚类指针(记为vbptr_B2A)指向父类，然后还要包含父类的所有内容
    + gcc/clang共享虚表指针，也就是说父类如果已经有虚表指针，那么子类中共享父类的虚表指针
    + sizeof(A)=4+4=8, sizeof(B)=4+sizeof(vbptr_B2A)+sizeof(A)=16, sizeof(C)=4+sizeof(vbptr_C2B)+sizeof(B)=24
    ```c++
    class A {
      char k[3];                // 字节对齐
      public:
        virtual void aa() {};
    };
    class B : public virtual A {
      char j[3];               
      public:
        virtual void bb() {};
    };
    class C : public virtual B {
      char i[3];
      public:
        virtual void cc() {};
    };
    ```
6. 评价多继承的优缺点
    + 多继承本身没有问题，如果运用得当可以事半功倍。稍有不慎，会出现一些严重现象——菱形继承，这样的继承方式会使得类的访问结构非常复杂。但不是不可处理，如可以通过`virtual`继承
    + 从哲学上来说，c++多重继承有必要存在，因为世界本来就不是单根的
    + 多重继承在面向对象的理论中**并非**必要的，因为它没有提供新的语义，可以通过单继承与复合结构取代。
    + 多重继承本身并不复杂，对象布局也不混乱，语言中有明确的定义。真正复杂的是使用了运行时多态的多重继承，因为语言对于多态的实现没有明确的定义。
7. `class C : public A, public B`如果出现相同的函数`foo`, 则可以通过`C.A::foo()`和`C.B::foo()`分别代表从A类中继承的`foo`和从B类中继承的`foo`
8. 基类与派生类的地址布局问题：对于`class B : public A`以及`B *pb = new B(); A *pa = dynamic_cast<B*>(pb); `
    + `pb == pa`, 会发生隐式类型转换即`pb == (B*)pa`。pa实际指向的地址是B类中指向父类A的部分，地址和pb不一样。但是进行隐式类型转换后(B*)pa指向的是pb指向的对象，因此是同一部分
9. 组合(a part of)与继承(a kind of)
    + 可替代性与行为有关，与子集无关。当评价一个潜在的继承关系时，重要的因素是可替代的行为，而不是子集。
    + 如眼鼻口耳是头的一部分(a part of，子集)，而非可替代性，所以他们是组合关系，不应该是继承关系
10. 运算符重载实际上是一个函数重载，所以编译程序对运算符重载的选择遵循着函数重载的选择原则
11. 运算符重载的函数一般采用成员函数或友元函数形式，这两种形式都可以访问类中的私有成员
    + 单目运算符只能重载成成员函数
12. 强制类型转换也是运算符：无参数，无返回类型（有返回值），以目标类型为函数名
    + string 强制转换成 char*
    ```c++
    class string {
      public:
        operator char*();
    }
    ```
13. 虚函数的运行开销有进行整数加法和指针引用的时间开销；定义一个虚表，有虚表指针的开销（不一定是一个，只是一般实现是一个虚表指针）
14. 能用虚函数解决的问题就不要用`dynamic_cast`, 能用`dynamic_cast`解决的问题就不要用`typeid`
    + `dynamic_cast`用于在类层次结构中漫游，对指针或引用进行自由的向上、向下或交叉转换，它带有“咨询”性质，而不是的强制转换（因为转换失败会返回NULL，而强转是一定成功的）
    + `typeid`用于获取一个对象或引用的确切类型
15. RTTI(Runtime Type Infomation)，运行时类型信息，其重要作用是动态判别执行时期的类型
16. RTTI是有用的，但因为一些理论上及方法论上的原因，它破坏了面向对象的纯洁性。相对于运行时的开销，其方法论的缺点更加突出。
    + 破坏了抽象
    + 因为运行时类型不确定，使程序变脆弱
    + 使程序缺乏扩展性：加入一个新类型就要去检查相关代码，这个过程编译器不会给任何作用


### 程序题
1. 虚函数覆盖虚函数问题
    ```c++
    class A {
      public:
        void virtual f() { cout << "A" << endl; };
    };
    class B : public A {
      public:
        void virtual f() { cout << "B" << endl; };
    };
    int main() {
      A* pa = new A();
      pa->f();              // A, 不存在多态的说法，多态的一个前提是父类指针指向子类对象，不要看到virtual就是一定是的多态
      b* pb = (B*)pa;
      pb->f();              // A, pa指向是没有变化的，还是指向父类A，不存在覆盖问题，也就不存在多态，这是子类指向父类指针

      delete pa, pb;
      pa = new B();
      pa->f();              // B, pa的类型依旧是A，指向了一个子类B对象，因此这里是多态
      pb = (B*)pa;
      pb->f();              // B
    }
    ```