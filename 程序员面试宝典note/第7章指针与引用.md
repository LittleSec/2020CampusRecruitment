1. 指针和引用的区别
    + 非空区别：引用必须指向某些对象，即必须初始化，如果某变量有些时候可能不指向任何对象，那么应该声明为指针。即不存在指向空值的引用
    + 合法性区别：因为上述一点，所以使用引用前不需要测试合法性，而在使用指针前总是应该测试其是否为`NULL/nullptr`
    + 可修改区别：指针可以被重新赋值以指向另外一个不同的对象，但引用总是指向在初始化时指定的对象，以后不能改变，但是指向对象的内容可以改变。有点像`int* const a = ***;`
    + 应用区别：如果存在不指向任何对象的可能，或者需要在不同时刻指向不同对象，就使用指针；如果总是指向一个对象且指向不会改变，则使用引用
2. `char *s`和`char c[]`的区别
    + char *s = "hello world"; // s是个指针，字符串存储在全局只读数据段，属于常量，即s[1] = 'a'非法
    + char s[] = "hello world"; // s是个数组，字符串存储在栈中，是局部变量
3. 编译器对的类成员的认识是距离对象的偏移量: 以下程序输出的是`m_a`的值，即1，因为`m_a`对A的偏移和`m_c`对B的偏移是一样的。
    ```c++
    class A {
      public:
        A() { m_a = 1; m_b = 2; };
        ~A() {};
        void func() { cout << m_a << m_b << endl; };
      private:
        int m_a, m_b;
    };
    class B {
      public:
        B() { m_c = 3; };
        ~B() {};
        void func() { cout << m_c << endl; };
      private:
        int m_a, m_b; 
    };
    int main() {
      A a;
      B *pb = (B*)(&a);
      pb->func();
    }
    ```
4. 函数的形参在**运行时**函数调用的时候才会分配存储空间.
5. 指针运算: 对于`int a[] = {1, 2, 3, 4, 5};`:
    + `a+1`指向第1个元素即2，即加1加的是`sizeof(int*)`
    + `&a+1`指向的是元素5后面的那个位置，即加1加的是`sizeof(a)`
6. 空指针和迷途指针的区别
    + 当`delete`一个指针时，实际上仅让编译器释放内存，指针本身依然存在，这就是一个迷途指针
    + 使用迷途指针和空指针都是非法的，都能造成程序崩溃，但空指针引用的崩溃相比之下是一种可预料的崩溃
7. c++中有`malloc/free`，为什么还要`new/delete`?
    + 对于非内部数据类型的对象而言，只用`malloc/free`无法满足动态对象需求。对象在创建的同时要自动执行构造函数，对象在消亡的之前要自动执行析构函数。
    + `malloc/free`是库函数而不是运算符，不在编译器的控制权限内，不能把执行构造函数和析构函数的任务强加于`malloc/free`
8. 句柄是一种指向指针的指针。
    + 在Windows中，句柄地址(稳定) --> 记载着对象在内存中的地址(不稳定) --> 实际对象
    + 在Windows中用句柄标记系统资源
9. 智能指针防止内存泄露的原理：
    + 如果在一个函数内用new动态分配一个对象，但在某些分支上没有执行delete就函数结束了，则会造成内存泄露
    + 如果使用智能指针，因为智能指针也一个对象，无论走什么分支，只要函数结束，退栈的时候编译器会调用智能指针的析构函数释放对象
10. `this`指针
    + 时刻指向这个实例本身
    + 本质是一个函数参数，只是编译器隐藏了。实际上成员函数默认的第一个参数为`T* const this`(即this的值不能变，其指向的内容可以变)
    + 只能在成员函数中使用，全局函数、静态函数都不能使用，因为这些函数不需要实例就能调用
    + 本身不占用对象空间，因为本质上是成员函数的参数，不管是否隐含都不占用对象空间，只在函数调用参数传递时占用栈空间
    + 大多数编译器通过ecx寄存器传递该参数
    + 只有成员函数里才有定义（因为它本质上是个参数）


### 阅读代码题
1. 以下代码的输出结果
    ```c++
    class A {
      public:
        int _a;
        A() { _a = 1;}
        void print() { cout << _a << endl; }
    };
    class B : public A {
      public:
        int _a;
        B() { _b = 2;}
    };
    int main() {
        B b;
        b.print();                  // print函数继承于class A，输出的是1
        cout << b._a << endl;       // class B的_a覆盖了class A的，因此输出2
    }
    ```
2. 以下程序哪一行崩溃
    ```c++
    struct S {
      int i;
      int *p;
    };
    int main() {
      S s;             // &s.i:0xf0     &s.p:0xf4
      int *p = &s.i;
      p[0] = 4;        //        4
      p[1] = 3;        //        4             3
      s.p = p;         //                     0xf0
      s.p[1] = 1;      //                      1
      s.p[0] = 2;      // (*1)=2，非法! 执行到该行崩溃 
    }
    ```
