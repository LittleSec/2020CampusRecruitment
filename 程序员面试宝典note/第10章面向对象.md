1. 面向对象的设计
    + 面向对象设计的三个原则：封装、继承、多态
    + 里氏代换原则(Liskov Substitution Principle): 是继承复用的基石：子类型必须能够替换他们的基类型。换言之，一个软件实体如果使用一个基类的话，那么一定适用于其子类，而且根本不能察觉出基类对象和子类对象的区别。只有衍生类替换基类的同时软件实体的功能没有发生变化，基类才能被真正复用。
    + 开闭原则(Open-close principle): 软件对扩展应该是开放的，对修改应该是关闭的
2. 对于一个空类，编译器默认产生4个成员函数：默认构造函数，析构函数，复制构造函数，赋值构造函数
3. 静态成员变量
    + 可在同一类的实例之间共享
    + 必须初始化，可通过`Type Classname::Variable = init;`初始化，即使静态成员变量是私有的，因为这是类，不是对象实例
4. 初始化列表的初始化变量顺序是根据成员变量的**声明顺序**来执行的，与初始化列表的顺序无关
5. 常量必须(只能)在构造函数的初始化列表里初始化
6. 对于继承类的对象，构造函数先执行父类再执行子类，析构函数先执行子类再执行父类
7. 虚析构函数的必要性：考虑如下代码
    ```c++
    CBase *pBase;
    CChild c;       // 调用CChild的构造函数
    pBase = &c;
    delete pBase;   // 如果CBase的析构函数不是虚函数，则调用CBase的，那么CChild的空间并没有释放，造成内存泄露
    ```
8. 析构函数可以是虚函数，为什么构造函数不能是虚函数
    + 虚函数允许用户调用一个只知道接口而不知道其准确对象类型的的函数，但是如果要创建一个对象，势必要知道对象的准确类型，因此构造函数不能是虚函数
9. 析构函数可以是内联函数
10. 虚函数有效，但虚函数有代价，每个有虚函数的对象都需要维护一个虚表，因此仅是一个很小的类且不想派生其他类，则没必要使用虚函数
    + 虚函数需要一次间接的寻址
11. 编译器对复制构造函数的的优化: 以下代码中func(5)理应调用两次复制构造函数，一次是形参副本，一次是返回值副本
    ```c++
    B func(B b) {};
    func(5); // 假设B里有一个int参数的构造函数
    ```
12. 若不想构造函数的参数类型发生隐式转换（成自己的类型），可以通过`explicit`关键字消除，即如果上述代码中B的带一个int参数的构造函数声明了`explicit`，则编译出错
13. 虚函数的声明必须与基类中的定义方式完全匹配，即返回类型、函数名、参数列表要一致（即使加了const也不行，那就是同名函数而已）
    + 有一个例外：返回类型可以是对基类的引用或指针，即派生类中的虚函数可以返回基类函数所返回类型的派生类的引用或指针
    + 示例代码
    ```c++
    // Derived是Base的派生类
    Base* Base::copy(Base*);
    Derived* Derived::copy(Base*);
    ```
14. 多态
    + 简单概括：一个接口，多种方法，在程序运行的过程中才决定调用的函数
    + 多态允许子类类型的指针赋值给父类类型的指针
    + 多态在c++中通过虚函数实现
    + 继承是为了代码重用，而多态更多是为了接口重用
15. 重载(overload)与覆盖(override)
    + 覆盖，也叫重写。虚函数就是允许子类重写父类的成员函数。参数列表、函数名、返回类型都要一致
    + 重载，允许存在多个**同名**函数，这些函数的**参数列表不同**，不属于面向对象编程范畴，在编译期间就确定了，是**静态**的。
16. 友元
    + 友元是一种定义在类外部的普通函数，但它需要在类里进行说明
    + 友元不是成员函数，但它可以访问类中的私有成员 ==> 破坏了类的封装性和隐蔽性
    + 可以是一个函数，称为友元函数；也可以是一个类，称为友元类
17. 构造函数遇到异常是不会调用析构函数的
    + c++保证对象构造要么成功要么失败的原则：从异常发生点按照成员变量的初始化的逆序释放成员
    + 上面原则针对的是初始化列表的方式，如果函数体类抛异常(如`new`不成功时抛异常)，则还是可能造成内存泄露
    + 解决办法：使用智能指针


### 程序题
1. 以下代码编译时出错的语句是
    ```c++
    struct Test {
      Test(int a) {};
      Test() {};
      void func() {};
    };
    int main() {
      Test a(1);
      a.func();
      Test b();  // 这里也算是错误，但编译时时检测不出来的，本意想调用无参的构造函数，应该写成Test b
      b.func();  // 这句无法编译，因为编译器认为b并不是个对象
    }
    ```
